---
day: Day 13
title: タイルパターン - Quarter-circles
difficulty: 3.5
tags: [tile, arc, offset, extrusion, pattern]
---

## ✅ Inputs

- `tile_size`: float – タイルの一辺のサイズ
- `offset`: float – アークを内外にオフセットする距離（中心合わせのため±で使う）
- `height`: float – 押し出し高さ
- `rows`: int – タイルの行数
- `cols`: int – タイルの列数

## ✅ Outputs

- `results`: list of `Brep` – 押し出しされたタイル構成ブロック群（全体パターン）

## ✅ Code

```python
import Rhino.Geometry as rg
import math
import random

results = []

def create_tile(base_x, base_y, rotation_deg):
    # 左下
    start0 = rg.Point3d(tile_size / 2, 0, 0)
    end0 = rg.Point3d(0, tile_size / 2, 0)
    tangent0 = rg.Vector3d(0, 1, 0)
    arc0 = rg.Arc(start0, tangent0, end0).ToNurbsCurve()
    arc0_pos = arc0.Offset(rg.Plane.WorldXY, offset, 0.001, rg.CurveOffsetCornerStyle.Sharp)[0]
    arc0_neg = arc0.Offset(rg.Plane.WorldXY, -offset, 0.001, rg.CurveOffsetCornerStyle.Sharp)[0]
    lofted0 = rg.Brep.CreateFromLoft([arc0_pos, arc0_neg], rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False)[0]

    # 右上
    start1 = rg.Point3d(tile_size / 2, tile_size, 0)
    end1 = rg.Point3d(tile_size, tile_size / 2, 0)
    tangent1 = rg.Vector3d(0, -1, 0)
    arc1 = rg.Arc(start1, tangent1, end1).ToNurbsCurve()
    arc1_pos = arc1.Offset(rg.Plane.WorldXY, offset, 0.001, rg.CurveOffsetCornerStyle.Sharp)[0]
    arc1_neg = arc1.Offset(rg.Plane.WorldXY, -offset, 0.001, rg.CurveOffsetCornerStyle.Sharp)[0]
    lofted1 = rg.Brep.CreateFromLoft([arc1_pos, arc1_neg], rg.Point3d.Unset, rg.Point3d.Unset, rg.LoftType.Normal, False)[0]

    # 押し出し
    path = rg.Line(rg.Point3d(0, 0, 0), rg.Point3d(0, 0, height)).ToNurbsCurve()
    solid0 = lofted0.Faces[0].CreateExtrusion(path, True)
    solid1 = lofted1.Faces[0].CreateExtrusion(path, True)

    # 平行移動 & 回転
    center = rg.Point3d(base_x + tile_size/2, base_y + tile_size/2, 0)
    move = rg.Transform.Translation(base_x, base_y, 0)
    rotate = rg.Transform.Rotation(math.radians(rotation_deg), center)

    for s in [solid0, solid1]:
        copy = s.DuplicateBrep()
        copy.Transform(move)
        copy.Transform(rotate)
        results.append(copy)

# グリッド配置
for row in range(rows):
    for col in range(cols):
        x = col * tile_size
        y = row * tile_size
        rotation = random.choice([0, 90])
        create_tile(x, y, rotation)
```

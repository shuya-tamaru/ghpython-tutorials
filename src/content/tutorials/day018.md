---
day: Day 18
title: æ³¢æ‰“ã¤ã‚µãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã«ãƒ¬ãƒ³ã‚¬ã‚’ç­‰é«˜ã§é…ç½®
difficulty: 4.0
tags: [surface, pattern, wave, contour, alignment, parametric]
---

## âœ… Inputs

- brick_w: float â€“ ãƒ¬ãƒ³ã‚¬ã®å¹…ï¼ˆXæ–¹å‘ï¼‰
- brick_h: float â€“ ãƒ¬ãƒ³ã‚¬ã®é«˜ã•ï¼ˆZæ–¹å‘ï¼‰
- brick_d: float â€“ ãƒ¬ãƒ³ã‚¬ã®å¥¥è¡Œãï¼ˆYæ–¹å‘ï¼‰
- gap_x: float â€“ æ¨ªæ–¹å‘ã®éš™é–“ï¼ˆXæ–¹å‘ç›®åœ°ï¼‰
- gap_z: float â€“ æ®µã”ã¨ã®éš™é–“ï¼ˆZæ–¹å‘ç›®åœ°ï¼‰
- num_x: int â€“ Xæ–¹å‘ã«ä¸¦ã¹ã‚‹ãƒ¬ãƒ³ã‚¬æ•°
- num_z: int â€“ Zæ–¹å‘ã«ç©ã‚€ãƒ¬ãƒ³ã‚¬æ®µæ•°
- wave_cycles_x: float â€“ Xæ–¹å‘ã«å…¥ã‚Œã‚‹æ³¢ã®ç¹°ã‚Šè¿”ã—æ•°
- wave_cycles_z: float â€“ Zæ–¹å‘ã«å…¥ã‚Œã‚‹æ³¢ã®ç¹°ã‚Šè¿”ã—æ•°
- amp_x: float â€“ Xæ–¹å‘ã®æ³¢ã®æŒ¯å¹…
- amp_z: float â€“ Zæ–¹å‘ã®æ³¢ã®æŒ¯å¹…

## âœ… Outputs

- results: list of Box â€“ ã‚µãƒ¼ãƒ•ã‚§ã‚¤ã‚¹å½¢çŠ¶ã«æ²¿ã£ã¦ç©ã¾ã‚ŒãŸãƒ¬ãƒ³ã‚¬ã®é›†åˆä½“

## âœ… Code

```python
# === ğŸ”§ å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹ ===
# brick_w = 200.0
# brick_h = 60.0
# brick_d = 100.0
# gap_x = 10.0
# gap_z = 10.0
# num_x = 20
# num_z = 50
# wave_cycles_x = 2.0
# wave_cycles_z = 2.0
# amp_x = 150.0
# amp_z = 150.0

import Rhino.Geometry as rg
import math

size_x = num_x * (brick_w + gap_x)
size_z = num_z * (brick_h + gap_z)

freq_x = wave_cycles_x * math.pi * 2 / size_x
freq_z = wave_cycles_z * math.pi * 2 / size_z

count_x = num_x
count_z = num_z

points_grid = []

for i in range(count_z + 1):
    row = []
    t_z = float(i) / count_z
    z = t_z * size_z

    for j in range(count_x + 1):
        t_x = float(j) / count_x
        x = t_x * size_x

        y = math.sin(x * freq_x) * amp_x + math.sin(z * freq_z) * amp_z
        pt = rg.Point3d(x, y, z)
        row.append(pt)

    points_grid.append(row)

flat_points = [pt for row in points_grid for pt in row]

surf = rg.NurbsSurface.CreateThroughPoints(
    flat_points, count_z + 1, count_x + 1, 3, 3, False, False
)

# === âœ‚ï¸ ç­‰é«˜ã‚«ãƒ¼ãƒ–å–å¾— + Boxé…ç½® ===
brep = rg.Brep.CreateFromSurface(surf)
results = []

for i in range(num_z):
    z = i * (brick_h + gap_z)
    plane = rg.Plane(rg.Point3d(0, 0, z), rg.Vector3d(0, 0, 1))
    contours = rg.Brep.CreateContourCurves(brep, plane)

    if not contours:
        continue

    for curve in contours:
        spacing = brick_w + gap_x
        params = curve.DivideByLength(spacing, True)

        for p in params:
            pt = curve.PointAt(p)
            tangent = curve.TangentAt(p)
            tangent.Unitize()

            xaxis = tangent
            zaxis = rg.Vector3d(0, 0, 1)
            yaxis = rg.Vector3d.CrossProduct(zaxis, xaxis)
            yaxis.Unitize()

            plane = rg.Plane(pt, xaxis, yaxis)

            # å¥‡æ•°æ®µã ã‘ Xæ–¹å‘ã«åŠãƒ¬ãƒ³ã‚¬ãšã‚‰ã™
            if i % 2 == 1:
                shift_vec = rg.Vector3d(xaxis) * (brick_w + gap_x) / 2
                plane.Origin += shift_vec

            # ãƒ¬ãƒ³ã‚¬Boxã‚’é…ç½®
            box = rg.Box(
                plane,
                rg.Interval(-brick_w / 2, brick_w / 2),
                rg.Interval(-brick_d / 2, brick_d / 2),
                rg.Interval(0, brick_h)
            )

            results.append(box)

```

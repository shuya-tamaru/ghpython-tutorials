---
day: Day 17
title: Sinæ³¢ã«æ²¿ã£ã¦ãƒ¬ãƒ³ã‚¬ã‚’é…ç½®ã—ç©ã¿ä¸Šã’ã‚‹
difficulty: 3.5
tags: [brick, wave, sin, alignment, orientation, stacked]
---

## âœ… Inputs

- brick_w: float â€“ ãƒ¬ãƒ³ã‚¬ã®å¹…ï¼ˆXæ–¹å‘ï¼‰
- brick_h: float â€“ ãƒ¬ãƒ³ã‚¬ã®é«˜ã•ï¼ˆZæ–¹å‘ï¼‰
- brick_d: float â€“ ãƒ¬ãƒ³ã‚¬ã®å¥¥è¡Œãï¼ˆYæ–¹å‘ï¼‰
- gap_x: float â€“ ãƒ¬ãƒ³ã‚¬é–“ã®Xæ–¹å‘éš™é–“ï¼ˆæ¨ªã®ç›®åœ°ï¼‰
- gap_z: float â€“ ãƒ¬ãƒ³ã‚¬é–“ã®Zæ–¹å‘éš™é–“ï¼ˆç¸¦ã®ç›®åœ°ï¼‰
- num_z: int â€“ Zæ–¹å‘ã®æ®µæ•°
- amplitude: float â€“ Sinæ³¢ã®æŒ¯å¹…ï¼ˆYæ–¹å‘ã®é«˜ã•ï¼‰
- frequency: float â€“ Sinæ³¢ã®å‘¨æ³¢æ•°ï¼ˆ1/æ³¢é•·ï¼‰
- length: float â€“ Sinæ³¢ã®Xæ–¹å‘é•·ã•
- resolution: int â€“ Sinæ³¢ã‚’æ§‹æˆã™ã‚‹ç‚¹ã®æ•°ï¼ˆæ»‘ã‚‰ã‹ã•ï¼‰

## âœ… Outputs

- results: list of Box â€“ æ›²ç·šæ–¹å‘ã«æ•´åˆ—ã—ã€ç©ã¿ä¸Šã’ã‚‰ã‚ŒãŸãƒ¬ãƒ³ã‚¬ã®é›†åˆä½“

## âœ… Code

```python
import Rhino.Geometry as rg
import math

# === ğŸ”§ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹ ===
# brick_w = 200.0
# brick_h = 60.0
# brick_d = 100.0

# gap_x = 40.0     # æ¨ªæ–¹å‘ã®ç›®åœ°
# gap_z = 2.0     # æ®µã”ã¨ã®ç¸¦ç›®åœ°
# num_z = 40        # æ®µæ•°

# amplitude = 400.0
# frequency = 0.01
# length = 3000.0
# resolution = 3

# === ğŸŒŠ Sinæ³¢ã‚«ãƒ¼ãƒ–ã‚’ç”Ÿæˆ ===
points = []
for i in range(resolution + 1):
    t = float(i) / resolution
    x = t * length
    y = math.sin(x * frequency) * amplitude
    pt = rg.Point3d(x, y, 0)
    points.append(pt)

curve = rg.Curve.CreateInterpolatedCurve(points, 3)

# === ğŸ§± æ›²ç·šã«æ²¿ã£ã¦æ®µã”ã¨ã«ãƒ¬ãƒ³ã‚¬ã‚’é…ç½® ===
spacing = brick_w + gap_x
params = curve.DivideByLength(spacing, True)

results = []

for z in range(num_z):
    z_shift = z * (brick_h + gap_z)
    is_odd = z % 2 == 1

    for p in params:
        pt = curve.PointAt(p)
        tangent = curve.TangentAt(p)
        tangent.Unitize()

        # åŸºæœ¬è»¸å®šç¾©
        xaxis = tangent
        zaxis = rg.Vector3d(0, 0, 1)
        yaxis = rg.Vector3d.CrossProduct(zaxis, xaxis)
        yaxis.Unitize()

        plane = rg.Plane(pt, xaxis, yaxis)

        # å¥‡æ•°æ®µã ã‘ Xè»¸æ–¹å‘ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆåŠãƒ¬ãƒ³ã‚¬åˆ†ï¼‰
        if is_odd:
            shift_vec = rg.Vector3d(xaxis)
            shift_vec *= (brick_w + gap_x) / 2
            plane.Origin += shift_vec

        # Zæ–¹å‘ã«æŒã¡ä¸Šã’ã‚‹
        plane.Origin += rg.Vector3d(0, 0, z_shift)

        # ãƒ¬ãƒ³ã‚¬ç”Ÿæˆ
        box = rg.Box(
            plane,
            rg.Interval(-brick_w/2, brick_w/2),
            rg.Interval(-brick_d/2, brick_d/2),
            rg.Interval(0, brick_h)
        )

        results.append(box)

---
day: Day 19
title: ç·¨ã¿ç‰©ã®ã‚ˆã†ãªäº¤å·®ãƒ‘ã‚¿ãƒ¼ãƒ³
difficulty: 3.0
tags: [sin, weave, pattern, pipe, curve, symmetry]
---

## âœ… Inputs

- length: float â€“ æ›²ç·šã®é•·ã•ï¼ˆX/Yæ–¹å‘ï¼‰
- amp: float â€“ Zæ–¹å‘ã®æ³¢ã®æŒ¯å¹…
- wave_cycles: float â€“ Sinæ³¢ã®ç¹°ã‚Šè¿”ã—æ•°
- res: int â€“ æ›²ç·šã®åˆ†å‰²æ•°ï¼ˆæ»‘ã‚‰ã‹ã•ï¼‰
- radius: float â€“ Pipeã®åŠå¾„

## âœ… Outputs

- results: list of Brep â€“ ç·¨ã¿ç›®æ§‹é€ ã‚’æ§‹æˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ç¾¤

## âœ… Code

```python
import Rhino.Geometry as rg
import math

# === ğŸ”§ å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹ ===
# length = 2000.0         # æ›²ç·šã®é•·ã•ï¼ˆX/Yæ–¹å‘ï¼‰
# amp = 30.0              # Zæ–¹å‘ã®æŒ¯å¹…
# wave_cycles = 10.0      # æ³¢ã®ç¹°ã‚Šè¿”ã—æ•°
# res = 50                # æ›²ç·šåˆ†å‰²æ•°
# radius = 20.0           # PipeåŠå¾„

period = length / wave_cycles
spacing = period / 2
offset_shift = spacing / 2

num_x = int(length // spacing)
num_y = int(length // spacing)

freq = wave_cycles * math.pi * 2 / length

# === ğŸ“ Sinæ³¢æ›²ç·šç”Ÿæˆ
def create_wave_curve(axis='x', offset=0.0, reverse=False):
    phase = math.pi if reverse else 0.0
    points = []
    for i in range(res + 1):
        t = float(i) / res
        u = t * length
        z = math.sin(u * freq + phase) * amp
        pt = rg.Point3d(u, offset, z) if axis == 'x' else rg.Point3d(offset, u, z)
        points.append(pt)
    return rg.Curve.CreateInterpolatedCurve(points, 3)

# === ğŸ” æ³¢ã‚’è¤‡è£½ã™ã‚‹å…±é€šé–¢æ•°
def generate_wave_family(axis, count, spacing, shift, start_reverse=True):
    curves = []
    for i in range(count):
        offset = i * spacing + shift
        reverse = (i % 2 == 1) if start_reverse else (i % 2 == 0)
        curves.append(create_wave_curve(axis, offset, reverse))
    return curves

# === ğŸ” X/Yæ–¹å‘ã®æ³¢ã‚’ç”Ÿæˆ
curves = []
curves.extend(generate_wave_family('x', num_y, spacing, offset_shift, start_reverse=True))
curves.extend(generate_wave_family('y', num_x, spacing, offset_shift, start_reverse=False))

# === ğŸ§µ PipeåŒ–
results = []
for c in curves:
    pipes = rg.Brep.CreatePipe(c, radius, False, rg.PipeCapMode.Round, True, 0.001, 0.001)
    if pipes:
        results.extend(pipes)
```